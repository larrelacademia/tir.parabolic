<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Tiro parabólico</title>
  <style>
    body {
      margin:0;
      background:#0D0D0D; /* NEGRO */
      color:#f9f8ef; /* ECRU WHITE */
      font-family:system-ui;
      display:flex;
      gap:20px;
      padding:18px;
    }
    .container {
      display:grid;
      grid-template-columns:420px 1fr;
      gap:18px;
      width:100%;
    }
    .panel {
      background:rgba(249,248,239,0.05); /* ECRU WHITE suave */
      padding:16px;
      border-radius:12px;
    }
    canvas {
      width:100%;
      height:600px;
      background:#1a1a1a; /* Negro más suave que el fondo */
      border-radius:10px;
    }
    label {
      display:block;
      margin-top:10px;
      font-size:16px;
      color:#f9f8ef; /* GIGAS */
    }
    input[type=range] {
      width:100%;
    }
    
    
    .pill {
      background:rgba(89, 186, 186,0.2); /* SULU con baja saturación */
      padding:6px 10px;
      border-radius:12px;
      font-size:13px;
    }
    .readouts {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    button {
      padding:6px 12px;
      border-radius:8px;
      cursor:pointer;
      border:none;
    }
    button.start {
      background:#277373; /* SASQUATCH SOCKS */
      color:#f9f8ef; /* ECRU WHITE */
    }
    button.gray {
      background:transparent;
      color:#f9f8efcc; /* ECRU WHITE suavizado */
      border:1px solid #448282; /* JADE */
    }
  </style>
</head>
<body>
<div class="container">
   <div class="panel">
      <img src="https://i.ibb.co/Q7YJTwgn/PRINCIPAL-BEIGE.png" 
         alt="PRINCIPAL-BEIGE" 
         style="width:200px; display:block; margin:0 auto 12px;" 
         border="0" />
  
    <h2>Simulador de tir parabòlic</h2>
    <label>Velocitat inicial: <span id="vVal">25</span> m/s</label>
    <input id="v" type="range" min="0" max="100" step="0.5" value="25">
    <label>Angle inicial: <span id="angleVal">45</span>°</label>
    <input id="angle" type="range" min="0" max="90" step="0.5" value="45">
    <label>Alçada inicial: <span id="hVal">0</span> m</label>
    <input id="h" type="range" min="0" max="100" step="1" value="0">
    <label>Gravetat: <span id="gVal">9.81</span> m/s²</label>
    <input id="g" type="range" min="0.5" max="20" step="0.1" value="9.8">
    <label>Zoom: <span id="scaleVal">100</span>%</label>
    <input id="scale" type="range" min="1" max="200" step="1" value="15">
    <button class="gray" id="fit" title="Ajustar a pantalla">Ajustar a pantalla</button>

    <label style="margin-top:8px"><input type="checkbox" id="showPrediction" checked> Mostrar predicció teòrica</label>
    <label><input type="checkbox" id="showTrail" checked> Mostrar rastre</label>

    <div style="margin-top:8px">
      <button class="start" id="start">Iniciar</button>
      <button class="gray" id="pause">Pausar</button>
      <button class="gray" id="reset">Reiniciar</button>
    </div>

    <label style="margin-top:12px">Temps (s): <span id="timeLabel">0.00</span></label>
    <input id="timeSlider" type="range" min="0" max="1" value="0" step="0.001">

    <div class="readouts">
      <div class="pill">t=<span id="t">0.00</span>s</div>
      <div class="pill">x=<span id="x">0.00</span>m</div>
      <div class="pill">y=<span id="y">0.00</span>m</div>
      <div class="pill">|v|=<span id="vmod">0.00</span>m/s</div>
      <div class="pill">Vx=<span id="vx">0.00</span>m/s</div>
      <div class="pill">Vy=<span id="vy">0.00</span>m/s</div>
      <div class="pill">θ=<span id="theta">0.00</span>°</div>
    </div>
  </div>

  <div class="panel"><canvas id="stage" width="1200" height="600"></canvas></div>
</div>

<script>
(()=> {
  const c = document.getElementById('stage'), ctx = c.getContext('2d');
  const hgt = c.height, wid = c.width, margin = 40;

  const v = document.getElementById('v'), angle = document.getElementById('angle'), h = document.getElementById('h'), g = document.getElementById('g'), scale = document.getElementById('scale'), fit = document.getElementById('fit');
  const showPrediction = document.getElementById('showPrediction'), showTrail = document.getElementById('showTrail');

  const vVal = document.getElementById('vVal'), angleVal = document.getElementById('angleVal'), hVal = document.getElementById('hVal'), gVal = document.getElementById('gVal'), scaleVal = document.getElementById('scaleVal');
  const start = document.getElementById('start'), pause = document.getElementById('pause'), reset = document.getElementById('reset'), timeSlider = document.getElementById('timeSlider');
  const tR = document.getElementById('t'), xR = document.getElementById('x'), yR = document.getElementById('y'), vR = document.getElementById('vmod'), vxR = document.getElementById('vx'), vyR = document.getElementById('vy'), thetaR = document.getElementById('theta'), timeLabel = document.getElementById('timeLabel');

  let trailPoints = [];

  function upd(){
    vVal.textContent = Number(v.value).toFixed(1);
    angleVal.textContent = Number(angle.value).toFixed(1);
    hVal.textContent = Number(h.value).toFixed(1);
    gVal.textContent = Number(g.value);
    scaleVal.textContent = Number(scale.value).toFixed(0);
  }

  // si cambias el zoom manualmente, limpia el rastro para evitar puntos desalineados
  function onParamChange(){
    computeMaxT();
    drawScene(curT);
  }

  [v, angle, h, g].forEach(e => e.addEventListener('input', ()=>{ upd(); onParamChange(); }));
  scale.addEventListener('input', ()=>{ trailPoints = []; upd(); onParamChange(); });

  upd();

  function toRad(d){ return d * Math.PI / 180; }

  function pos(t,p){
    const vx = p.v0 * Math.cos(p.ang), vy = p.v0 * Math.sin(p.ang);
    return {
      x: vx * t,
      y: p.h0 + vy * t - 0.5 * p.g * t * t,
      vx: vx,
      vy: vy - p.g * t,
      speed: Math.hypot(vx, vy - p.g * t)
    };
  }

  function flightTime(p){
    const a = -0.5 * p.g, b = p.v0 * Math.sin(p.ang), c0 = p.h0;
    const disc = b*b - 4*a*c0;
    if (disc < 0) return 0;
    const r1 = (-b + Math.sqrt(disc)) / (2*a), r2 = (-b - Math.sqrt(disc)) / (2*a);
    return Math.max(r1, r2);
  }

  // metros -> coordenadas canvas (píxeles)
  function m2c(x,y){
    const zoom = scale.value / 100;
    const pxPerMeter = 100 * zoom;
    return { cx: margin + x * pxPerMeter, cy: hgt - margin - y * pxPerMeter };
  }

  // dibuja flecha con cabeza
  function drawArrow(x1,y1,x2,y2,color){
    ctx.save();
    ctx.strokeStyle = color; ctx.fillStyle = color; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    const ang = Math.atan2(y2 - y1, x2 - x1), head = 8;
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2 - head * Math.cos(ang - Math.PI/6), y2 - head * Math.sin(ang - Math.PI/6));
    ctx.lineTo(x2 - head * Math.cos(ang + Math.PI/6), y2 - head * Math.sin(ang + Math.PI/6));
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  // calcula zoom ideal para encajar la trayectoria (en %)
  function autoZoom(){
    const p = { v0: +v.value, ang: toRad(+angle.value), h0: +h.value, g: +g.value };
    const T = flightTime(p);
    // obtén bounds muestreando la trayectoria
    let maxX = 0, maxY = Math.max(0, p.h0);
    const samples = 200;
    for(let i=0;i<=samples;i++){
      const P = pos(T * i / samples, p);
      if(P.x > maxX) maxX = P.x;
      if(P.y > maxY) maxY = P.y;
    }
    // evitar división por cero: si maxX o maxY muy pequeños, considerar 1 metro mínimo
    const safeMaxX = Math.max(1e-6, maxX);
    const safeMaxY = Math.max(1e-6, maxY);
    const zoomX = (wid - 2*margin) / (safeMaxX * 100);
    const zoomY = (hgt - 2*margin) / (safeMaxY * 100);
    let result = Math.min(zoomX, zoomY) * 100;
    // clamp con límites del slider
    const minZ = Number(scale.min), maxZ = Number(scale.max);
    if (!isFinite(result)) result = minZ;
    result = Math.max(minZ, Math.min(maxZ, result));
    return result;
  }

  fit.onclick = () => {
    trailPoints = []; // limpiar rastro porque cambia la escala
    const z = autoZoom();
    scale.value = Math.round(z);
    upd();
    drawScene(curT);
  };

  let simMax = 1;
  function computeMaxT(){
    const p = { v0: +v.value, ang: toRad(+angle.value), h0: +h.value, g: +g.value };
    simMax = flightTime(p);
    timeSlider.max = simMax.toFixed(3);
  }

  function drawAxes(maxX,maxY){
    ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, hgt - margin); ctx.lineTo(wid, hgt - margin); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(margin, 0); ctx.lineTo(margin, hgt); ctx.stroke();
    ctx.font = '15px sans-serif'; ctx.fillStyle = '#fff';
    const stepX = Math.max(1, Math.ceil(maxX/10)), stepY = Math.max(1, Math.ceil(maxY/10));
    for(let x = 0; x <= maxX; x += stepX){
      const p = m2c(x, 0);
      ctx.fillRect(p.cx, hgt - margin, 1, 5);
      ctx.fillText(x.toFixed(0), p.cx - 8, hgt - margin + 15);
    }
    for(let y = stepY; y <= maxY; y += stepY){
      const p = m2c(0, y);
      ctx.fillRect(margin - 5, p.cy, 5, 1);
      ctx.fillText(y.toFixed(0), margin - 28, p.cy + 4);
    }
  }

  function drawPrediction(pms,T){
    ctx.save(); ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(89, 186, 186,0.6)'; ctx.lineWidth=2; ctx.beginPath();
    const steps = 200;
    for(let i=0;i<=steps;i++){
      const P = pos(T * i / steps, pms);
      const pt = m2c(P.x, Math.max(0, P.y));
      if(i===0) ctx.moveTo(pt.cx, pt.cy); else ctx.lineTo(pt.cx, pt.cy);
    }
    ctx.stroke(); ctx.restore();
  }

  function drawScene(t){
    ctx.clearRect(0,0,wid,hgt);
    const p = { v0: +v.value, ang: toRad(+angle.value), h0: +h.value, g: +g.value };
    const T = flightTime(p);

    // calculamos máximos para ejes y para fit preview
    let maxX = 0, maxY = Math.max(0, p.h0);
    for(let i=0;i<=100;i++){
      const P = pos(T * i / 100, p);
      if(P.x > maxX) maxX = P.x;
      if(P.y > maxY) maxY = P.y;
    }

    // ejes y grillas
    drawAxes(maxX * 1.1, Math.max(maxY * 1.1, 1));

    // predicción teórica
    if(showPrediction.checked) drawPrediction(p, T);

    // posición actual
    const P = pos(t, p);
    const pt = m2c(P.x, Math.max(0, P.y));

    // rastro (trail) — rastro almacenado como puntos en píxeles (se limpia si cambias zoom)
    if(showTrail.checked && trailPoints.length > 0){
      ctx.strokeStyle='rgba(255, 61, 120,0.4)'; ctx.lineWidth=2; ctx.beginPath();
      trailPoints.forEach((q,i)=>{ if(i===0) ctx.moveTo(q.cx,q.cy); else ctx.lineTo(q.cx,q.cy); });
      ctx.stroke();
    }

    // proyectil
    ctx.beginPath(); ctx.arc(pt.cx, pt.cy, 7, 0, Math.PI*2); ctx.fillStyle = '#38bdf8'; ctx.fill();

    // guías hasta ejes
    ctx.setLineDash([4,4]); ctx.strokeStyle='rgba(255,255,255,0.3)';
    ctx.beginPath(); ctx.moveTo(pt.cx, pt.cy); ctx.lineTo(pt.cx, hgt - margin); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(pt.cx, pt.cy); ctx.lineTo(margin, pt.cy); ctx.stroke();
    ctx.setLineDash([]);

    // etiquetas x,y junto al proyectil
    ctx.fillStyle = '#fff';
    ctx.fillText(`x=${P.x.toFixed(1)} m`, pt.cx - 28, hgt - margin + 20);
    ctx.fillText(`y=${Math.max(0,P.y).toFixed(1)} m`, margin - 30, pt.cy - 6);

    // vectores de velocidad (escala dependiente del zoom)
    const zoom = scale.value / 100;
    const f = Math.max(8, (100 * zoom) * 0.18); // factor para longitud de flechas
    const vxEnd = { x: pt.cx + P.vx * f, y: pt.cy };
    const vyEnd = { x: pt.cx, y: pt.cy - P.vy * f };
    const vEnd  = { x: pt.cx + P.vx * f, y: pt.cy - P.vy * f  };

    drawArrow(pt.cx, pt.cy, vxEnd.x, vxEnd.y, '#d5f476'); // rojo Vx
    drawArrow(pt.cx, pt.cy, vyEnd.x, vyEnd.y, '#00a874'); // verde Vy
    drawArrow(pt.cx, pt.cy, vEnd.x, vEnd.y, '#ff3d78');   // azul |v|

    // etiquetas de los vectores cerca de sus puntas
    ctx.font = '15px sans-serif';
    ctx.fillStyle = '#d5f476'; ctx.fillText(`${P.vx.toFixed(1)} m/s`, vxEnd.x + 6, vxEnd.y + 5);
    ctx.fillStyle = '#00a874'; ctx.fillText(`${P.vy.toFixed(1)} m/s`, vyEnd.x + 6, vyEnd.y - 2);
    ctx.fillStyle = '#ff3d78'; ctx.fillText(`${P.speed.toFixed(1)} m/s`, vEnd.x + 6, vEnd.y - 2);

    // actualizar lecturas en panel
    tR.textContent = t.toFixed(2);
    xR.textContent = P.x.toFixed(2);
    yR.textContent = Math.max(0, P.y).toFixed(2);
    vR.textContent = P.speed.toFixed(2);
    vxR.textContent = P.vx.toFixed(2);
    vyR.textContent = P.vy.toFixed(2);
    thetaR.textContent = (Math.atan2(P.vy, P.vx) * 180 / Math.PI).toFixed(1);
    timeLabel.textContent = t.toFixed(2);
  }

  let running = false, last = null, simT = 0, curT = 0;
  computeMaxT();

  function loop(ts){
    if(!running) return;
    if(!last) last = ts;
    const dt = (ts - last)/1000;
    last = ts;
    simT += dt;
    if(simT > simMax){ simT = simMax; running = false; }
    if(showTrail.checked){
      const P = pos(simT, { v0: +v.value, ang: toRad(+angle.value), h0: +h.value, g: +g.value });
      trailPoints.push(m2c(P.x, Math.max(0, P.y)));
    }
    timeSlider.value = simT;
    curT = simT;
    drawScene(simT);
    requestAnimationFrame(loop);
  }

  start.onclick = () => { computeMaxT(); simT = 0; trailPoints = []; running = true; last = null; requestAnimationFrame(loop); };
  pause.onclick = () => running = false;
  reset.onclick = () => { running = false; simT = 0; trailPoints = []; drawScene(0); timeSlider.value = 0; };
  timeSlider.oninput = e => { simT = +e.target.value; curT = simT; drawScene(simT); };

  function computeMaxT(){ const p = { v0: +v.value, ang: toRad(+angle.value), h0: +h.value, g: +g.value }; simMax = flightTime(p); timeSlider.max = simMax.toFixed(3); }

  // al cargar por primera vez
  drawScene(0);

})();
</script>
</body>

</html>






